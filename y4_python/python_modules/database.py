import os
import sqlite3
import csv
from typing import Iterable, List, Mapping, NamedTuple

import numpy as np
from rdkit.DataStructs.cDataStructs import BitVectToText, CreateFromBitString

from .util import fingerprint_from_smiles, Consts
from .orbital_calculations import MolecularOrbital

# for idx, row in enumerate(blyp_data):
#     if row[0] == pm7_data[idx][0]:
#         blyp_data[idx] = tuple(row[0] + pm7_data[idx][1] + row[1])
#     else:
#         print(f"line {idx} , molNames not the same, blyp name = {row[0]} pm7 name = {pm7_data[idx][0]}")

class DatasetItem(NamedTuple):
    mol_id: str
    E_pm7: float
    E_blyp: float
    smiles: str
    fingerprint: object
    serialized_molecular_orbital: str

class DB:

    BLYP = 'E_blyp'
    PM7 = 'E_pm7'

    def __init__(self):
        self.conn = sqlite3.connect("D:\\Projects\\Y4Project\\python\\molecule_database.db")
        self.cur = self.conn.cursor()

    def table_exists(self):
        r = self.cur.execute("SELECT name FROM sqlite_master WHERE type=`table` AND name=`dataset`")
        if len(r.fetchall()) == 1:
            return True
        else:
            return False

    def create_table(self):
        """
        mol_id is the ZINC id eg: `ZINC000000038842`
        E_pm7, E_blyp are energies from each calculation eg -0.31885
        smiles is the smiles repr for that molecule
        rdk_fingerprint is the bitvector for the fingerprint generated by RDKFingerprint
        calculated_molecular_orbital is a CalculatedMolecularOrbital converted to a dictionary and serialized with json.
        """


        self.cur.execute("""
        CREATE TABLE IF NOT EXISTS dataset (
            mol_id text, E_pm7 real, E_blyp real, smiles text, rdk_fingerprint text, calculated_molecular_orbital text,
        )
        """)

    def add_dataset(self, dataset: Iterable[DatasetItem]):
        for mol_id, pm7, blyp, smiles, fingerprint_bitvect, calculated_molecular_orbital in dataset:
            self.add_row(DatasetItem(mol_id, pm7, blyp, smiles, fingerprint_bitvect, calculated_molecular_orbital))
        self.commit()
        
    def add_row(self, row: DatasetItem):
        mol_id, pm7, blyp, smiles, fingerprint_bitvect, calculated_molecular_orbital = row
        self.cur.execute(
                "INSERT INTO dataset VALUES (?,?,?,?,?,?)", (mol_id, float(pm7), float(blyp), smiles, fingerprint_bitvect, calculated_molecular_orbital)
            )

    def commit(self):
        self.conn.commit()

    def close(self):
        self.conn.commit()
        self.conn.close()

    ######################
    ### Reading Operations
    ######################

    def get_all(self):
        r = self.cur.execute(
            "SELECT * FROM dataset ORDER BY `rowid`"
        )
        return r.fetchall()

    def get_row_from_mol_id(self, mol_id):
        r = self.cur.execute(
            f"SELECT * FROM dataset WHERE mol_id='{mol_id}'"
        )
        fetch = r.fetchall()
        if fetch.__len__() > 1:
            print(f"WARNING: fetching row for  mol_id {mol_id} gave more than one row result")
        return fetch[0]

    def get_dE_from_mol_id(self, mol_id):
        row = self.get_row_from_mol_id(mol_id)
        pm7, blyp = row[1:3]
        dE = blyp - pm7
        return dE

    def base_get_energies(self, energy: str) -> List[float]:
        "energy: str = self.PM7 or self.BLYP"
        col = "E_pm7" if energy == self.PM7 else "E_blyp"
        r = self.cur.execute(
            f"SELECT {col} FROM dataset ORDER BY `rowid`"
        )
        ### Reshape [(val,), (val2,)...] into [val, val2,...]
        return np.asarray(r.fetchall())[:,0]

    def get_blyp_energies(self) -> List[float]:
        "Return BLYP energies sorted by rowid"
        return self.base_get_energies(self.BLYP)

    def get_pm7_energies(self) -> List[float]:
        "Return PM7 energies sorted by rowid"
        return self.base_get_energies(self.PM7)

    def get_pm7_energies_with_smiles(self):
        r = self.cur.execute(
            f"SELECT `{self.PM7}`, `smiles` FROM dataset ORDER BY `rowid`"
        )
        return r.fetchall()

    def get_mol_ids(self) -> List[str]:
        "Return mol_ids ordered by rowid"
        r = self.cur.execute(
            "SELECT mol_id FROM dataset ORDER BY `rowid`"
        )
        return r.fetchall()

    def get_smiles(self) -> np.ndarray:
        "Return smiles ordered by rowid"
        r = self.cur.execute(
            "SELECT `smiles` FROM dataset ORDER BY `rowid`"
        )
        return np.array(r.fetchall())[:,0]

    def get_smiles_for_mol(self, mol_id):
        r = self.cur.execute(
            f"SELECT `smiles` WHERE `mol_id`={mol_id}"
        )
        return r.fetchone()

    def get_fingerprints(self):
        r = self.cur.execute(
            "SELECT `fingerprints` FROM dataset ORDER BY `rowid`"
        )
        return list(map(
            lambda x: CreateFromBitString(x[0])
            , r.fetchall()
        ))


def main():

    inputDir = os.path.join("..","sampleInputs")
    orbitalsDir = "D:\\Projects\\y4-project\\sampleInputs\\11k_orbitals"
    BLYP_file = "D:\\Projects\\y4-project\\sampleInputs\\11k_BLYP_homo_energies.csv"
    PM7_file = "D:\\Projects\\y4-project\\sampleInputs\\11k_PM7_homo_energies.csv"

    with open(BLYP_file, 'r', newline='') as F:
        blyp_reader = csv.reader(F)
        ### data is [[molName, E_blyp], ...]
        #blyp_data = np.array([tuple(row) for row in blyp_reader])

    # mol_ids: List[str] = blyp_data.T[0]
    # blypEnergies: np.ndarray[np.str_] = blyp_data.T[1]

    with open(PM7_file, 'r', newline='') as F:
        pm7_reader = list(csv.reader(F))
        ### Each pm7_row in reader is [molName, E_pm7]
        # we filter out rows that didn't exist in the blyp data.
        # pm7_data = [tuple(row) for row in pm7_reader if row[0] in mol_ids]
        pm7_data = [tuple(row) for row in pm7_reader]

    # pm7Energies: np.ndarray[np.str_] = np.asarray(pm7_data).T[1]

    db = DB()

    db.create_table()

    ### Read the smiles representations of each molecule into a dictionary.
    ### This gives us O(1) lookup time, and ~1000 entries shouldn't be too memory demanding. (TODO: what about 100,000? :O )
    SMILES_file = "D:\\Projects\\y4-project\\sampleInputs\\SMILES_labels.csv"
    SMILES_dict: Mapping[str,str] = {}
    with open(SMILES_file, 'r') as F:
        reader = csv.reader(F, dialect='excel-tab')
        ### Each row is (smiles, molName)
        for row in reader:
            SMILES_dict[row[1]] = row[0]

    ### TODO: New loop, which uses all the generators
    for idx, blyp_row in enumerate(blyp_reader):
        blyp_mol_id, E_blyp = blyp_row
        pm7_mol_id, E_pm7 = pm7_row = pm7_reader[idx]
        if blyp_mol_id != pm7_mol_id:
            raise Exception(f"blyp_mol_id != pm7_mol_id. blyp_mol_id = {blyp_mol_id}, pm7_mol_id={pm7_mol_id}")
        smiles = SMILES_dict[blyp_mol_id]
        rdk_fingerprint = fingerprint_from_smiles(smiles, Consts.RDK_FP)
        serialized_molecular_orbital = MolecularOrbital.fromJsonFile(
            os.path.join(orbitalsDir, f"{blyp_mol_id}.json"), mo_number=MolecularOrbital.HOMO
        ).serialize() 
    

        db.add_row(
            DatasetItem(blyp_mol_id, float(E_pm7), float(E_blyp), smiles, rdk_fingerprint, serialized_molecular_orbital)
        )
    db.commit()
    db.close()

    # ### This is memory intensive, however it makes sure there is no error.
    # SMILES_list: List[str] = [SMILES_dict[mol_id] for mol_id in mol_ids]


    # rdk_fingerprint_list: List[object] = []
    # for smiles in SMILES_list:
    #     fp = fingerprint_from_smiles(smiles, Consts.RDK_FP)
    #     rdk_fingerprint_list.append(fp)

    ### Calc and append MolecularOrbital objects.
    ### TODO: convert to generator expression
    '''
    serialized_molecular_orbitals = []
    for mol_id in mol_ids:
        orbital_file = os.path.join(orbitalsDir, f"{mol_id}.json")
        homo = MolecularOrbital.fromJsonFile(orbital_file=orbital_file, mo_number=MolecularOrbital.HOMO,)
        serialized: str = homo.serialize()
        serialized_molecular_orbitals.append(serialized)
    '''
    # serialized_molecular_orbitals = (
    #     MolecularOrbital.fromJsonFile(
    #         os.path.join(orbitalsDir, f"{mol_id}.json"), mo_number=MolecularOrbital.HOMO
    #     ).serialize() 
    #     for mol_id in mol_ids
    # )

    # dataset: Iterable[DatasetItem] = []
    # for idx in range(len(mol_ids)):
    #     db.add_row((mol_ids[idx], float(pm7Energies[idx]), float(blypEnergies[idx]), SMILES_list[idx], rdk_fingerprint_list[idx], serialized_molecular_orbitals))
    # ### Add dataset
    # #dataset = np.asarray([mol_ids, pm7Energies, blypEnergies, SMILES_list, fingerprint__bitvect_list]).T


if __name__ == "__main__":
    main()